use crate::capture::should_skip_capture;
use crate::config;
use crate::endpoints::{self, EndpointCatalog};
use std::collections::HashMap;
use std::fs;
use std::io::Write;

/// A UI action observed in the browser and the API calls it triggered.
struct Workflow {
    /// e.g. "click", "type", "select"
    action_type: String,
    /// e.g. "button", "link", "input"
    role: String,
    /// Human-readable label of the element
    label: String,
    /// Value typed (for type/select actions)
    value: Option<String>,
    /// Normalized endpoint patterns triggered by this action
    triggered_calls: Vec<String>,
    /// Timestamp of the action (for sorting by recency)
    timestamp: String,
}

/// Generate digest.md for a given app.
/// Reads endpoints.json, config.json, sessions/latest.json, and captures/*.jsonl
/// to produce a concise markdown summary for AI agents.
pub fn generate_for_app(app_name: &str) {
    let app_dir = config::data_dir().join("apps").join(app_name);

    // 1. Read endpoints.json
    let endpoints_path = app_dir.join("endpoints.json");
    let catalog: EndpointCatalog = fs::read_to_string(&endpoints_path)
        .ok()
        .and_then(|s| serde_json::from_str(&s).ok())
        .unwrap_or_default();

    // 2. Read config.json for domains
    let config_path = app_dir.join("config.json");
    let app_config: Option<config::AppConfig> = fs::read_to_string(&config_path)
        .ok()
        .and_then(|s| serde_json::from_str(&s).ok());

    // 3. Read sessions/latest.json
    let session_path = app_dir.join("sessions").join("latest.json");
    let session: config::SessionData = fs::read_to_string(&session_path)
        .ok()
        .and_then(|s| serde_json::from_str(&s).ok())
        .unwrap_or_default();

    // 4. Read auth.json
    let auth_path = app_dir.join("auth.json");
    let auth: Option<endpoints::AuthInfo> = fs::read_to_string(&auth_path)
        .ok()
        .and_then(|s| serde_json::from_str(&s).ok());

    // 5. Build workflows from captures
    let workflows = build_workflows(&app_dir);

    // 6. Build the markdown
    let now = chrono::Utc::now();
    let timestamp = now.to_rfc3339_opts(chrono::SecondsFormat::Secs, true);

    let mut md = String::new();

    // Header
    md.push_str(&format!("# {} -- API Digest\n", app_name));
    md.push_str(&format!(
        "> Auto-generated by harharhar. Last updated: {}\n",
        timestamp
    ));

    // Session freshness line
    let (age_str, is_stale) = format_session_age(&session.captured_at, &now);
    if !session.captured_at.is_empty() {
        md.push_str(&format!(
            "> Session captured: {} ({})\n",
            session.captured_at, age_str
        ));
    }
    md.push('\n');

    // Domains
    if let Some(ref cfg) = app_config {
        if !cfg.domains.is_empty() {
            md.push_str("## Domains\n");
            for d in &cfg.domains {
                md.push_str(&format!("- {}\n", d));
            }
            md.push('\n');
        }
    }

    // Observed Workflows
    if !workflows.is_empty() {
        md.push_str("## Observed Workflows\nActions observed in the browser and the API calls they triggered.\n\n");
        md.push_str("| Action | API Calls Triggered |\n");
        md.push_str("|--------|-------------------|\n");
        for wf in &workflows {
            let action_desc = format_action_description(&wf.action_type, &wf.role, &wf.label, &wf.value);
            let calls = wf.triggered_calls.join(", ");
            md.push_str(&format!("| {} | {} |\n", action_desc, calls));
        }
        md.push('\n');
    }

    // Key Endpoints — top 30, skip noise
    let filtered_endpoints: Vec<&endpoints::Endpoint> = catalog
        .endpoints
        .iter()
        .filter(|ep| {
            // Skip endpoints with no observed URLs or whose URLs are noise
            ep.observed_urls
                .first()
                .map(|u| !should_skip_capture(u))
                .unwrap_or(false)
        })
        .take(30)
        .collect();

    if !filtered_endpoints.is_empty() {
        md.push_str("## Key Endpoints\nRanked by frequency. Noise endpoints filtered out.\n\n");
        md.push_str("| # | Endpoint | Freq | Auth | Response Type |\n");
        md.push_str("|---|----------|------|------|---------------|\n");
        for (i, ep) in filtered_endpoints.iter().enumerate() {
            let auth_str = if ep.auth_required {
                build_auth_type_short(ep)
            } else {
                "none".to_string()
            };
            let resp_type = ep
                .response_content_types
                .first()
                .map(|ct| shorten_content_type(ct))
                .unwrap_or_else(|| "-".to_string());
            md.push_str(&format!(
                "| {} | {} | {}x | {} | {} |\n",
                i + 1,
                ep.pattern,
                ep.times_seen,
                auth_str,
                resp_type
            ));
        }
        md.push('\n');
    }

    // Auth Summary
    md.push_str("## Auth Summary\n");
    // Cookies
    if !session.cookies.is_empty() {
        let cookie_names: Vec<&String> = session.cookies.keys().collect();
        let preview: Vec<&str> = cookie_names.iter().take(6).map(|s| s.as_str()).collect();
        let preview_str = preview.join(", ");
        if cookie_names.len() > 6 {
            md.push_str(&format!(
                "- **Cookies**: {}, ... ({} total)\n",
                preview_str,
                cookie_names.len()
            ));
        } else {
            md.push_str(&format!(
                "- **Cookies**: {} ({} total)\n",
                preview_str,
                cookie_names.len()
            ));
        }
    }
    // Auth headers
    if !session.auth_headers.is_empty() {
        let header_descs: Vec<String> = session
            .auth_headers
            .iter()
            .map(|(name, val)| {
                let pattern = if let Some(space) = val.find(' ') {
                    format!("{} ({} ...)", name, &val[..space])
                } else {
                    name.clone()
                };
                pattern
            })
            .collect();
        md.push_str(&format!("- **Headers**: {}\n", header_descs.join(", ")));
    }
    // CSRF
    if !session.csrf_tokens.is_empty() {
        let csrf_names: Vec<&String> = session.csrf_tokens.keys().collect();
        md.push_str(&format!(
            "- **CSRF**: {}\n",
            csrf_names
                .iter()
                .map(|s| s.as_str())
                .collect::<Vec<_>>()
                .join(", ")
        ));
    }
    // Additional auth mechanisms from auth.json
    if let Some(ref auth_info) = auth {
        for mech in &auth_info.mechanisms {
            if mech.mech_type == "cookie" {
                // Already covered above from session
            } else if mech.mech_type == "header" {
                // Already covered above from session
            }
        }
        if let Some(ref login_url) = auth_info.login_url {
            md.push_str(&format!("- **Login URL**: {}\n", login_url));
        }
        if !auth_info.observed_refresh_endpoints.is_empty() {
            md.push_str(&format!(
                "- **Token refresh**: {}\n",
                auth_info.observed_refresh_endpoints.join(", ")
            ));
        }
    }
    md.push('\n');

    // Session Status
    md.push_str("## Session Status\n");
    if !session.domain.is_empty() {
        md.push_str(&format!("- Domain: {}\n", session.domain));
    }
    if !session.captured_at.is_empty() {
        md.push_str(&format!("- Captured: {} ({})\n", session.captured_at, age_str));
    }
    md.push_str(&format!("- Cookies: {} active\n", session.cookies.len()));
    md.push_str(&format!(
        "- Auth headers: {} active\n",
        session.auth_headers.len()
    ));
    if is_stale {
        md.push_str("- WARNING: Session may be stale (>1 hour old) -- re-browse to refresh\n");
    }
    md.push('\n');

    // Quick Reference
    md.push_str("## Quick Reference\n");
    md.push_str("See `examples.sh` for copy-paste curl commands.\n");
    md.push_str("See `endpoints.json` for full endpoint catalog with response shapes.\n");
    md.push_str("See `captures/` for raw API traffic.\n");

    // Write digest.md
    let digest_path = app_dir.join("digest.md");
    if let Ok(mut file) = fs::File::create(&digest_path) {
        let _ = file.write_all(md.as_bytes());
    }
}

/// Build workflow entries from all JSONL capture files.
/// For each ui-action entry, collect the next API calls within 2 seconds
/// as "triggered" calls, normalize their URLs to endpoint patterns,
/// deduplicate, and sort by recency.
fn build_workflows(app_dir: &std::path::Path) -> Vec<Workflow> {
    let captures_dir = app_dir.join("captures");
    let entries = match fs::read_dir(&captures_dir) {
        Ok(e) => e,
        Err(_) => return vec![],
    };

    // Collect all JSONL file paths, sorted by name (chronological)
    let mut jsonl_files: Vec<std::path::PathBuf> = entries
        .flatten()
        .filter(|e| {
            e.path()
                .extension()
                .and_then(|ext| ext.to_str())
                == Some("jsonl")
        })
        .map(|e| e.path())
        .collect();
    jsonl_files.sort();

    // Parse all entries from all files
    let mut all_entries: Vec<serde_json::Value> = Vec::new();
    for file_path in &jsonl_files {
        let contents = match fs::read_to_string(file_path) {
            Ok(c) => c,
            Err(_) => continue,
        };
        for line in contents.lines() {
            if let Ok(data) = serde_json::from_str::<serde_json::Value>(line) {
                all_entries.push(data);
            }
        }
    }

    // Walk through entries, correlating ui-actions with following API calls.
    // Track the current annotation — when present, it overrides the auto-generated
    // action description for subsequent ui-actions until consumed.
    let mut workflows: Vec<Workflow> = Vec::new();
    let mut current_action: Option<(Workflow, f64)> = None; // (workflow, action_epoch_ms)
    let mut current_annotation: Option<String> = None;

    for entry in &all_entries {
        let entry_type = entry.get("type").and_then(|v| v.as_str()).unwrap_or("");

        if entry_type == "annotation" {
            let ann_label = entry
                .get("label")
                .and_then(|v| v.as_str())
                .unwrap_or("")
                .to_string();
            if !ann_label.is_empty() {
                current_annotation = Some(ann_label);
            }
            continue;
        }

        if entry_type == "ui-action" {
            // Flush previous action if it had triggered calls
            if let Some((wf, _)) = current_action.take() {
                if !wf.triggered_calls.is_empty() {
                    workflows.push(wf);
                }
            }

            let action_type = entry
                .get("action")
                .and_then(|v| v.as_str())
                .unwrap_or("")
                .to_string();
            let role = entry
                .get("role")
                .and_then(|v| v.as_str())
                .unwrap_or("")
                .to_string();
            let value = entry
                .get("value")
                .and_then(|v| v.as_str())
                .map(|s| s.to_string());
            let timestamp = entry
                .get("timestamp")
                .and_then(|v| v.as_str())
                .unwrap_or("")
                .to_string();

            // Use annotation label if available, otherwise use the element label
            let label = if let Some(ref ann) = current_annotation {
                ann.clone()
            } else {
                entry
                    .get("label")
                    .and_then(|v| v.as_str())
                    .unwrap_or("")
                    .to_string()
            };
            // Consume annotation after use
            current_annotation = None;

            let epoch = parse_timestamp_ms(&timestamp);

            let wf = Workflow {
                action_type,
                role,
                label,
                value,
                triggered_calls: Vec::new(),
                timestamp: timestamp.clone(),
            };
            current_action = Some((wf, epoch));
            continue;
        }

        // Skip non-request entries (xhr-start, cookies, navigation)
        if entry_type == "xhr-start" || entry_type == "cookies" || entry_type == "navigation" {
            continue;
        }

        // If we have a current action, check if this call is within 2 seconds
        if let Some((ref mut wf, action_epoch)) = current_action {
            let entry_ts = entry
                .get("timestamp")
                .and_then(|v| v.as_str())
                .unwrap_or("");
            let entry_epoch = parse_timestamp_ms(entry_ts);

            let diff_ms = entry_epoch - action_epoch;
            if diff_ms >= 0.0 && diff_ms <= 2000.0 && wf.triggered_calls.len() < 5 {
                // Get the URL and normalize it
                if let Some(url_str) = entry.get("url").and_then(|v| v.as_str()) {
                    if should_skip_capture(url_str) {
                        continue;
                    }
                    if let Ok(parsed) = url::Url::parse(url_str) {
                        let method = entry
                            .get("method")
                            .and_then(|v| v.as_str())
                            .unwrap_or("GET");
                        let path = parsed.path();
                        let pattern = format!("{} {}", method, endpoints::normalize_path(path));
                        if !wf.triggered_calls.contains(&pattern) {
                            wf.triggered_calls.push(pattern);
                        }
                    }
                }
            }
        }
    }

    // Flush last action
    if let Some((wf, _)) = current_action.take() {
        if !wf.triggered_calls.is_empty() {
            workflows.push(wf);
        }
    }

    // Deduplicate: same action description + same triggered patterns = show once
    let mut seen: HashMap<String, usize> = HashMap::new();
    let mut deduped: Vec<Workflow> = Vec::new();
    for wf in workflows {
        let key = format!(
            "{}|{}|{}|{}|{}",
            wf.action_type,
            wf.role,
            wf.label,
            wf.value.as_deref().unwrap_or(""),
            wf.triggered_calls.join(",")
        );
        if let Some(idx) = seen.get(&key) {
            // Update timestamp to the more recent one
            if wf.timestamp > deduped[*idx].timestamp {
                deduped[*idx].timestamp = wf.timestamp;
            }
        } else {
            seen.insert(key, deduped.len());
            deduped.push(wf);
        }
    }

    // Sort by recency (most recent first)
    deduped.sort_by(|a, b| b.timestamp.cmp(&a.timestamp));

    // Limit to a reasonable number for the digest
    deduped.truncate(20);

    deduped
}

/// Parse a timestamp string (RFC3339 or ISO8601) into milliseconds since epoch.
/// Returns 0.0 if parsing fails.
fn parse_timestamp_ms(ts: &str) -> f64 {
    // Try chrono parsing (handles both +00:00 offset and Z suffix)
    if let Ok(dt) = chrono::DateTime::parse_from_rfc3339(ts) {
        return dt.timestamp_millis() as f64;
    }
    // Try parsing as ISO 8601 with fractional seconds and Z suffix
    // (e.g. "2026-02-22T01:11:29.152Z")
    if let Ok(dt) = chrono::NaiveDateTime::parse_from_str(ts, "%Y-%m-%dT%H:%M:%S%.fZ") {
        return dt
            .and_utc()
            .timestamp_millis() as f64;
    }
    0.0
}

/// Format the age of a session as human-readable text.
/// Returns (age_string, is_stale).
fn format_session_age(captured_at: &str, now: &chrono::DateTime<chrono::Utc>) -> (String, bool) {
    let dt = if let Ok(dt) = chrono::DateTime::parse_from_rfc3339(captured_at) {
        dt.with_timezone(&chrono::Utc)
    } else {
        return ("unknown".to_string(), true);
    };

    let duration = *now - dt;
    let total_secs = duration.num_seconds();
    if total_secs < 0 {
        return ("just now".to_string(), false);
    }

    let is_stale = total_secs > 3600; // > 1 hour

    let age_str = if total_secs < 60 {
        format!("{} seconds ago", total_secs)
    } else if total_secs < 3600 {
        let mins = total_secs / 60;
        if mins == 1 {
            "1 minute ago".to_string()
        } else {
            format!("{} minutes ago", mins)
        }
    } else if total_secs < 86400 {
        let hours = total_secs / 3600;
        if hours == 1 {
            "1 hour ago".to_string()
        } else {
            format!("{} hours ago", hours)
        }
    } else {
        let days = total_secs / 86400;
        if days == 1 {
            "1 day ago".to_string()
        } else {
            format!("{} days ago", days)
        }
    };

    (age_str, is_stale)
}

/// Format a UI action into a human-readable description for the table.
fn format_action_description(
    action_type: &str,
    role: &str,
    label: &str,
    value: &Option<String>,
) -> String {
    // Normalize action_type: "click_ref" -> "click", "type_ref" -> "type", "select_ref" -> "select"
    let verb = action_type
        .strip_suffix("_ref")
        .unwrap_or(action_type);

    let label_clean = label.replace('|', "/");

    match value {
        Some(val) => format!(
            "{} {} \"{}\" value=\"{}\"",
            verb,
            role,
            truncate_str(&label_clean, 40),
            truncate_str(val, 30)
        ),
        None => format!(
            "{} {} \"{}\"",
            verb,
            role,
            truncate_str(&label_clean, 50)
        ),
    }
}

/// Shorten a content-type header to its essential part.
fn shorten_content_type(ct: &str) -> String {
    // "application/json; charset=UTF-8" -> "application/json"
    ct.split(';').next().unwrap_or(ct).trim().to_string()
}

/// Build a short auth type description from an endpoint.
fn build_auth_type_short(_ep: &endpoints::Endpoint) -> String {
    // We don't have per-endpoint header info in the Endpoint struct,
    // so just indicate it requires auth
    "cookie+header".to_string()
}

/// Truncate a string to max_len, appending "..." if truncated.
fn truncate_str(s: &str, max_len: usize) -> String {
    if s.len() <= max_len {
        s.to_string()
    } else {
        format!("{}...", &s[..max_len])
    }
}
